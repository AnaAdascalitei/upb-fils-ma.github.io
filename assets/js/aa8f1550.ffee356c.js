"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2476],{4604:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var r=t(7624),s=t(2172);const i={sidebar_position:4,slug:"/lab/03"},a="03 - Exceptions & Interrupts",o={id:"lab/03/03",title:"03 - Exceptions & Interrupts",description:"The purpose of this lab is to understand how exceptions and hardware interrupts work and how they can be used, how to set a hard fault handler,",source:"@site/docs/lab/03/03.md",sourceDirName:"lab/03",slug:"/lab/03",permalink:"/docs/lab/03",draft:!1,unlisted:!1,editUrl:"https://github.com/UPB-FILS-MA/upb-fils-ma.github.io/edit/main/docs/lab/03/03.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,slug:"/lab/03"},sidebar:"tutorialSidebar",previous:{title:"02 - Memory Mapped IO & GPIO",permalink:"/docs/lab/02/"},next:{title:"Project",permalink:"/docs/project"}},l={},d=[{value:"Resources",id:"resources",level:2},{value:"What is an exception?",id:"what-is-an-exception",level:2},{value:"What is an interrupt?",id:"what-is-an-interrupt",level:2},{value:"Exception and Interrupt Handling",id:"exception-and-interrupt-handling",level:2},{value:"RP2040",id:"rp2040",level:2},{value:"Boot",id:"boot",level:3},{value:"Interrupts",id:"interrupts",level:3},{value:"Available interrupt request signals (IRQ)",id:"available-interrupt-request-signals-irq",level:4},{value:"GPIO Interrupts",id:"gpio-interrupts",level:4},{value:"Handling a HardFault",id:"handling-a-hardfault",level:2},{value:"Register a HardFault handler",id:"register-a-hardfault-handler",level:3},{value:"Triggering a hard fault",id:"triggering-a-hard-fault",level:3},{value:"Handle Interrupts using <code>embedded-hal</code>",id:"handle-interrupts-using-embedded-hal",level:2},{value:"Setup the peripherals",id:"setup-the-peripherals",level:3},{value:"Enable interrupt",id:"enable-interrupt",level:3},{value:"Give back the pins",id:"give-back-the-pins",level:3},{value:"Enable the IO_BANK0 IRQ in the NVIC",id:"enable-the-io_bank0-irq-in-the-nvic",level:3},{value:"Define the interrupt handler",id:"define-the-interrupt-handler",level:3},{value:"Handle Interrupts using <code>embassy-rs</code>",id:"handle-interrupts-using-embassy-rs",level:2},{value:"Define the task function",id:"define-the-task-function",level:3},{value:"Pass the your function to the task spawner",id:"pass-the-your-function-to-the-task-spawner",level:3},{value:"Passing states between tasks",id:"passing-states-between-tasks",level:3},{value:"Inspect binaries",id:"inspect-binaries",level:2},{value:"Install cargo binutils",id:"install-cargo-binutils",level:3},{value:"Check section headers",id:"check-section-headers",level:3},{value:"Disassemble a specific section",id:"disassemble-a-specific-section",level:3},{value:"Exercises",id:"exercises",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.M)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"03---exceptions--interrupts",children:"03 - Exceptions & Interrupts"}),"\n",(0,r.jsxs)(n.p,{children:["The purpose of this lab is to understand how exceptions and hardware interrupts work and how they can be used, how to set a hard fault handler,\nregister interrupts and ",(0,r.jsx)(n.em,{children:"use interrupts"}),"  with embassy-rs."]}),"\n",(0,r.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Raspberry Pi Ltd"}),", ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.a,{href:"https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf",children:"RP2040 Datasheet"})})]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://developer.arm.com/documentation/dui0662/latest/",children:"Cortex-M0+ Devices Generic User Guide"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://embassy.dev/book/dev/runtime.html",children:"Embassy documentation"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"what-is-an-exception",children:"What is an exception?"}),"\n",(0,r.jsxs)(n.p,{children:["Exceptions describe any condition that requires the processor to stop what it is doing\nand do something else. Section 2.3.2 of ",(0,r.jsx)(n.a,{href:"https://documentation-service.arm.com/static/5f04abc8dbdee951c1cdc9f7?token=",children:"Cortex-M0+ Devices generic User Guide"})," lists 7 types of exceptions:"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Exception"}),(0,r.jsx)(n.th,{children:"Priority"}),(0,r.jsx)(n.th,{children:"Descriptions"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Reset"}),(0,r.jsx)(n.td,{children:"-15"}),(0,r.jsx)(n.td,{children:"Triggered by the system at startup to start the software"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"NMI"}),(0,r.jsx)(n.td,{children:"-14"}),(0,r.jsx)(n.td,{children:"Non Maskable Interrupts, an external interrupt that cannot be ignored, usually used for low latency peripheral needs the attention of the MCU"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"HardFault"}),(0,r.jsx)(n.td,{children:"-13"}),(0,r.jsx)(n.td,{children:"Triggered by the MCU in case of a fault (div by 0, memory fault, ...)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"SVC"}),(0,r.jsx)(n.td,{children:"-5"}),(0,r.jsx)(n.td,{children:"Supervisor call, triggered usually by a process running on top of the embedded operating system when it wants to make a system call"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"PendSV"}),(0,r.jsx)(n.td,{children:"-2"}),(0,r.jsx)(n.td,{children:"Used for pending system calls"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"SysTick"}),(0,r.jsx)(n.td,{children:"-1"}),(0,r.jsx)(n.td,{children:"Triggered by a periodic timer, usually used by an embedded operating system for context switch"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Interrupt (IRQ)"}),(0,r.jsx)(n.td,{children:"0 and above"}),(0,r.jsx)(n.td,{children:"Triggered by a peripheral, or generated by a software request"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"what-is-an-interrupt",children:"What is an interrupt?"}),"\n",(0,r.jsx)(n.p,{children:"A hardware interrupt is an type of exception which is a synchronous or asynchronous signal from a peripheral that signals the occurrence of an event that must be handled by the processor. Interrupt handling has the effect of suspending a program's normal thread of execution and launching an interrupt service routine (ISR)."}),"\n",(0,r.jsx)(n.p,{children:"Generally, to associate an interrupt with a specific routine in the program, the processor uses the interrupt vector table (IVT). In this table, each interrupt is associated with the address to which the program will jump when the interrupt is triggered. These addresses are predefined and are mapped in program memory."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"InterruptVector",src:t(1924).c+"",width:"564",height:"670"})}),"\n",(0,r.jsx)(n.p,{children:"The image above illustrates the whole  vector table of ARM Cortex-M0.\nIt includes exceptions mapped from address 0x04 to 0x40+4n (n depends on the processor type). Lower address means higher priority.\nHigher priority exceptions can interrupt lower priority exceptions."}),"\n",(0,r.jsx)(n.h2,{id:"exception-and-interrupt-handling",children:"Exception and Interrupt Handling"}),"\n",(0,r.jsx)(n.p,{children:"When an interrupt request happens the first thing that the processor does is to memorize its current state. For ARM Cortex-M0 this happens by pushing 8 words or registered data into the main stack to provide the information\nneed to return the processor to what it was doing before before the interrupt request was called. This part is called the stack frame and it includes registers 0 through 3, register 12, the link register, the program counter and the program status register."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"StackFrame",src:t(4748).c+"",width:"1054",height:"602"})}),"\n",(0,r.jsx)(n.p,{children:'ARM Cortex-M microcontrollers also use a Nested Vectored Interrupt Controller (NVIC).The NVIC is specifically designed to handle these interrupts more efficiently. Interrupt addresses in the NVIC memory region are set according to their priority: the lower the address, the higher the priority. As suggested by the "Nested" in its name, the NVIC supports nested interrupts. This means that if a higher priority interrupt occurs while another interrupt is being processed, the controller can pause the current interrupt service routine (ISR), handle the higher priority interrupt, and then resume the interrupted ISR. This feature is crucial for responsive and real-time processing.'}),"\n",(0,r.jsxs)(n.p,{children:["Exception handlers are registerd using the ",(0,r.jsx)(n.code,{children:"exception"})," macro provided by the ",(0,r.jsx)(n.code,{children:"cortex-m-rt"})," crate."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[exception]\nunsafe fn ExceptionName() {\n\n}\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["The name of the exception handler function matters, as this is the way the ",(0,r.jsx)(n.code,{children:"exception"})," macro knows for which exception to\nregister the handler. Valid exception names are ",(0,r.jsx)(n.code,{children:"HardFault"}),", ",(0,r.jsx)(n.code,{children:"SysTick"}),", or any other exception name of the MCU."]})}),"\n",(0,r.jsx)(n.h2,{id:"rp2040",children:"RP2040"}),"\n",(0,r.jsx)(n.p,{children:"The RP2040 is an ARM Cortex-M0+ dual core processor. It does have some particularities."}),"\n",(0,r.jsx)(n.h3,{id:"boot",children:"Boot"}),"\n",(0,r.jsx)(n.p,{children:"The RP2040 boots from an internal bootloader that sets the initial interrupt IVT."}),"\n",(0,r.jsx)(n.mermaid,{value:"flowchart LR\n    S(PowerUp) --\x3e I\n    subgraph I0[Internal Boot Loader]\n        I{BOOTSEL\n        Pressed} -- Yes --\x3e U\n        I -- NO --\x3e R(Read \n        Boot Loader \n        @x1000_0000)\n        R -- Error --\x3e U(Show USB \n        Drive)\n    end\n    R -- Success --\x3e E2(Load\n    Interrupt\n    Vector)\n    E2 -- Fault --\x3e E3(Jump to \n    HardFault \n    Handler)\n    E3 -- Fault --\x3e L(Lockup\n    or\n    Reset)\n    E2 --\x3e S2(Set Stack \n    Pointer)\n    S2 --\x3e E(Jump to \n    Reset \n    Exception \n    Handler)\n    E -- Invalid --\x3e E3\n    E --\x3e F(Fetch \n    Instruction)\n\n    classDef memory fill:#B0E3E6,stroke:#0E8088\n    classDef instruction fill:#B1DDF0,stroke:#10739E\n    classDef processor fill:#FFE6CC,stroke:#D79B00\n    classDef exception fill:#F8CECC,stroke:#B85450\n    classDef error fill:#ff0000,stroke:#ae0000,color:#ffffff\n    classDef start fill:#00ef00\n    classDef rom fill:#f7ffe7\n\n    class A,E,E2,S2 instruction\n    class R,F memory\n    class B,V,R2,I,I2,I3,H,U processor\n    class L error\n    class E3 exception\n    class S start\n    class I0 rom"}),"\n",(0,r.jsxs)(n.p,{children:["The before starting the actual code written into Flash, the internal bootloader loads a secondary bootloader that\nis written in Flash (the first 256 bytes) together with the developer's app.\nThis is the bootloader section that was described in ",(0,r.jsx)(n.a,{href:"/docs/lab/02#bootloader",children:"lab 02"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"The IVT that the Flash application provides start after the secondary bootloader, at address 0x100."}),"\n",(0,r.jsx)("div",{align:"center",children:(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"FlashAddress",src:t(3668).c+"",width:"405",height:"695"})})}),"\n",(0,r.jsx)(n.h3,{id:"interrupts",children:"Interrupts"}),"\n",(0,r.jsx)(n.p,{children:"The RP2040 chip has two cores (processors), and each core has its own NVIC. Each core's NVIC is connected to the same set of hardware interrupt lines with one exception: IO Interrupts. In the RP2040, IO interrupts are organized by banks, and each core has its own set of IO interrupts for each bank. The IO interrupts for each core are completely independent. For instance, Processor 0 (Core 0) can be interrupted by an event on GPIO pin 0 in bank 0, while Processor 1 (Core 1) can be interrupted by a separate event on GPIO pin 1 in the same bank. Each processor responds only to its own interrupts, allowing them to operate independently or to handle different tasks simultaneously without interfering with each other."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"rp2040 subsystem",src:t(2660).c+"",width:"845",height:"369"})}),"\n",(0,r.jsx)(n.h4,{id:"available-interrupt-request-signals-irq",children:"Available interrupt request signals (IRQ)"}),"\n",(0,r.jsx)(n.p,{children:"On RP2040, only the lower 26 IRQ signals are connected on the NVIC, as seen in the table below, and IRQs 26 to 31 are tied to zero (never firing).\nThe core can still be forced to enter the relevant interrupt handler by writing bits 26 to 31 in the NVIC ISPR register."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Supported IRQ",src:t(7180).c+"",width:"701",height:"228"})}),"\n",(0,r.jsx)(n.p,{children:"The priority order is determined for these signals is determined by :"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["First, the dynamic priority level configured per interrupt by the ",(0,r.jsx)(n.code,{children:"NVIC_IPR0-7"})," registers. The Cortex-M0+ implements\nthe two most significant bits of an 8-bit priority field, so four priority levels are available, and the numerically-lowest\nlevel (level 0) is the highest priority."]}),"\n",(0,r.jsx)(n.li,{children:"Second, for interrupts with the same dynamic priority level, the lower-numbered IRQ has higher priority (using the\nIRQ numbers given in the table above)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"NVIC by prio",src:t(1344).c+"",width:"906",height:"635"})}),"\n",(0,r.jsx)(n.h4,{id:"gpio-interrupts",children:"GPIO Interrupts"}),"\n",(0,r.jsx)(n.p,{children:"All GPIO pins in Raspberry Pi Pico support interrupts. The interrupts can be classified into three types:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Level High"}),": An interrupt occurs while a pin is HIGH or at logic 1."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Level Low"}),": An interrupt occurs while a pin is LOW or at logic 0."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Rising Edge"}),": Interrupt occurs when a pin transitions from a LOW to HIGH."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Falling Edge"}),": Interrupt occurs when a pin transitions from HIGH to LOW."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"alt text",src:t(8932).c+"",width:"448",height:"164"})}),"\n",(0,r.jsx)(n.h2,{id:"handling-a-hardfault",children:"Handling a HardFault"}),"\n",(0,r.jsx)(n.p,{children:"There are several reasons why a hard fault is triggered:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"invalid memory"})," reads and writes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"invalid"})," address of the ",(0,r.jsx)(n.em,{children:"reset handler"})," (not the case for RP2040, as the real reset handler is in the Bootrom)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"invalid"})," address of the ",(0,r.jsx)(n.em,{children:"initial stack pointer"})," (not the case for RP2040, as the real reset handler is in the Bootrom)"]}),"\n",(0,r.jsxs)(n.li,{children:["using the ",(0,r.jsx)(n.em,{children:"svc"})," instruction ",(0,r.jsx)(n.em,{children:"in the HardFault handler"})]}),"\n",(0,r.jsxs)(n.li,{children:["using the ",(0,r.jsx)(n.em,{children:"svc"})," instruction ",(0,r.jsx)(n.em,{children:"NMI handler"})]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"register-a-hardfault-handler",children:"Register a HardFault handler"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"cortex-m-rt"})," crate allows an easy way of registering a hard fault handler by using\nthe ",(0,r.jsx)(n.code,{children:"exception"})," macro."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[exception]\nunsafe fn HardFault(_frame: &ExceptionFrame) -> ! {\n    loop{}\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"ExceptionFrame"})," parameter contains the state of the processor at the moment of the hard fault occured.\nIt contains the stack frame (registers) that the processor pushed on the stack."]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsx)(n.p,{children:"The hard fault handler is now allowed to return, as usually, unless an embedded operating system is used, this error is not recoverable."})}),"\n",(0,r.jsx)(n.h3,{id:"triggering-a-hard-fault",children:"Triggering a hard fault"}),"\n",(0,r.jsxs)(n.p,{children:["The easiest way of forcing a hard fault is to try to read or write to or from a memory location that is not valid.\nFor the RP2040, an invalid memory address is ",(0,r.jsx)(n.code,{children:"0xf000_0000"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// define an invalid memory address\nconst INVALID_ADDRESS: *const u32 = 0xf000_0000 as *const u32;\n\n// write to it\nunsafe {\n    // this triggers a hard fault\n    write_volatile(INVALID_ADDRESS, 0);\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"handle-interrupts-using-embedded-hal",children:["Handle Interrupts using ",(0,r.jsx)(n.code,{children:"embedded-hal"})]}),"\n",(0,r.jsx)(n.p,{children:"Setting up an interrupt is a bit more complicated than handling\na simple exception because we also need to enable that interrupt and bind it to the signal coming from a peripheral.\nAdditionally, we need to manually clear the interrupt (signal that we handled the interrupt) in the\ninterrupt handler, otherwise as soon as the interrupt handler finishes, it gets called again."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// Add the interrupt macro\nuse hal::pac::interrupt;\nuse rp2040_hal::gpio;\n\n// The GPIO interrupt type we're going to generate\nuse rp2040_hal::gpio::Interrupt::EdgeLow;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"setup-the-peripherals",children:"Setup the peripherals"}),"\n",(0,r.jsx)(n.p,{children:"If peripherals will be used in the interrupt handler function we need to set up a mutex to safely access them."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"/// This pin will be our interrupt source.\n/// It will trigger an interrupt if pulled to ground (via a switch or jumper wire)\ntype ButtonPin = gpio::Pin<gpio::bank0::Gpio0, gpio::FunctionSioInput, gpio::PullUp>;\n\ntype Button = (ButtonPin);\n\n/// This how we transfer our Button pins into the Interrupt Handler.\n/// We'll have the option hold the Button using the Button type.\n/// This will make it a bit easier to unpack them later.\nstatic GLOBAL_PINS: Mutex<RefCell<Option<Button>>> = Mutex::new(RefCell::new(None));\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"enable-interrupt",children:"Enable interrupt"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"\n// Set up the GPIO pin that will be our input\nlet in_pin = pins.gpio0.reconfigure();\n\n// Trigger on the 'falling edge' of the input pin.\n// This will happen as the button is being pressed\nin_pin.set_interrupt_enabled(EdgeLow, true);\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"give-back-the-pins",children:"Give back the pins"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// Give away our pins by moving them into the `GLOBAL_PINS` variable.\ncritical_section::with(|cs| {\n    GLOBAL_PINS.borrow(cs).replace(Some((led, in_pin)));\n});\n\n"})}),"\n",(0,r.jsx)(n.h3,{id:"enable-the-io_bank0-irq-in-the-nvic",children:"Enable the IO_BANK0 IRQ in the NVIC"}),"\n",(0,r.jsx)(n.p,{children:"so that the NVIC interrupt controller\nwill jump to the interrupt function when the interrupt occurs."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:" unsafe {\n        pac::NVIC::unmask(pac::Interrupt::IO_IRQ_BANK0);\n        }\n"})}),"\n",(0,r.jsx)(n.h3,{id:"define-the-interrupt-handler",children:"Define the interrupt handler"}),"\n",(0,r.jsx)(n.p,{children:"When defining an interrupt handler we need to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Add ",(0,r.jsx)(n.code,{children:"#[interrupt]"})," attribute which requires the cortex-m-rt crate for defining interrupt handlers."]}),"\n",(0,r.jsx)(n.li,{children:"Add code for that should run after button is pressed"}),"\n",(0,r.jsxs)(n.li,{children:["Take the gpio's resources that we defined, clear interrupt flag so that it doesn't enter ",(0,r.jsx)(n.code,{children:"IO_IRQ_BANK0()"})," again without a button press."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[interrupt]\nfn IO_IRQ_BANK0() {\n\n    // Do something\n    //Example: toggle LED\n\n    static mut BUTTON: Option<Button> = None;\n\n    critical_section::with(|cs| {\n        *BUTTON = GLOBAL_PINS.borrow(cs).take();\n    });\n    \n    // Need to check if our Option<ButtonPins> contains our pins\n    if let Some(button) = BUTTON {\n\n        // Clear the interrupt so that it doesn't enter the ISR again\n        button.clear_interrupt(EdgeLow);\n\n        //give away the borrowed button\n        critical_section::with(|cs| {\n        GLOBAL_PINS.borrow(cs).replace(Some((button)));\n    });\n\n    }\n\n    \n}\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"To use pins from main into the interrupt handler we will need to setup mutexes as well."})}),"\n",(0,r.jsxs)(n.h2,{id:"handle-interrupts-using-embassy-rs",children:["Handle Interrupts using ",(0,r.jsx)(n.code,{children:"embassy-rs"})]}),"\n",(0,r.jsx)(n.p,{children:"In Embassy, handling interrupts does not involve manually setting up interrupt service routines (ISRs) in the traditional sense that you might be used to with bare-metal or lower-level embedded programming. Instead, Embassy abstracts away the hardware-specific details and provides a higher-level async API for working with hardware events, including interrupts."}),"\n",(0,r.jsxs)(n.p,{children:["Embassy uses Rust's ",(0,r.jsx)(n.code,{children:"async"}),"/",(0,r.jsx)(n.code,{children:"await"})," syntax to provide an easier way to write non-blocking embedded applications. This approach allows you to wait for events (like GPIO pin changes, which could be triggered by hardware interrupts underneath). In a way that looks synchronous but is actually non-blocking and handled asynchronously by the Embassy executor."]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"Async and await mechanisms will be discuses in more detail in course_04 and lab_05."})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"alt text",src:t(6780).c+"",width:"827",height:"709"})}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"Unlike the usb drive, GPIO pins don't need explicit interrupt binding.\nAll interrupts handlers are already associated to the type of the input signal (rising edge, level low etc.)"})}),"\n",(0,r.jsx)(n.p,{children:"For example, if you're waiting for a button press, you don't need to set up the interrupt yourself; you simply use Embassy's GPIO API to wait for the pin change event"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"button.wait_for_rising_edge().await\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If we want the main loop to keep running regardless of the button state, we need to define a new task. A task in Embassy is an ",(0,r.jsx)(n.code,{children:"async"})," function that will run in parallel with other tasks. It can pause its execution at certain points, waiting for some conditions to be met (like waiting for an I/O operation to complete, a timer to elapse, or an external event to occur), and then resume where it left off."]}),"\n",(0,r.jsx)(n.h3,{id:"define-the-task-function",children:"Define the task function"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[embassy_executor::task]\nasync fn my_task() {\n    // initialize gpio\n    loop {\n        \n        //Wait for button button to be pressed\n        button.wait_for_rising_edge().await;\n        //Do something only if button was pressed\n        //(Here should be the logic for your interrupt request handler)\n        //Example: turn on the LED\n        \n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"pass-the-your-function-to-the-task-spawner",children:"Pass the your function to the task spawner"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use embassy_executor::Spawner;\n\n#[embassy_executor::main]\nasync fn main(spawner: Spawner) {\n\n    //  Spawn my_task\n    spawner.spawn(my_task()).unwrap();\n\n    loop {\n        //Do something\n        //...\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"passing-states-between-tasks",children:"Passing states between tasks"}),"\n",(0,r.jsxs)(n.p,{children:["Sharing data safely between tasks can be done using shared resources that ensure access is synchronized to prevent race conditions and other concurrency issues. Rust's ",(0,r.jsx)(n.code,{children:"core::sync::atomic"})," provides types such as ",(0,r.jsx)(n.code,{children:"AtomicBool"}),", ",(0,r.jsx)(n.code,{children:"AtomicIsize"}),", ",(0,r.jsx)(n.code,{children:"AtomicUsize"})," that can make read and write operations to be executed atomically. This means that read and write operations cannot be interrupted by interrupts or other tasks."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use core::sync::atomic::{AtomicU32, Ordering};\n\nstatic SHARED_VAL: AtomicU32 = AtomicU32::new(0 /*initial value*/);\n\n//read value in task\nlet val = SHARED_VAL.load(Ordering::Relaxed);\n\n//write value in task\nSHARED_VAL.store(val, Ordering::Relaxed);\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"For scenarios where atomic operations are not sufficient and you need to protect more complex interactions or data structures, using a Mutex from Embassy is more appropriate. Embassy's Mutex is designed to be used in asynchronous environments, allowing tasks to await the lock without blocking."})}),"\n",(0,r.jsx)(n.h2,{id:"inspect-binaries",children:"Inspect binaries"}),"\n",(0,r.jsxs)(n.p,{children:["When working in Rust, ",(0,r.jsx)(n.code,{children:"rust-objdump"})," can be used to inspect the compiled output to see sections and interleaved code. This is particularly useful to inspect code and debug."]}),"\n",(0,r.jsx)(n.h3,{id:"install-cargo-binutils",children:"Install cargo binutils"}),"\n",(0,r.jsxs)(n.p,{children:["Before you can use ",(0,r.jsx)(n.code,{children:"rust-objdump"})," with Rust projects, you'll need to install ",(0,r.jsx)(n.code,{children:"cargo-binutils"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"cargo install cargo-binutils\nrustup component add llvm-tools-preview\n"})}),"\n",(0,r.jsx)(n.h3,{id:"check-section-headers",children:"Check section headers"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"rust-objdump --section-headers target/thumbv6m-none-eabi/debug/<executable_name>\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"\nSections:\nIdx Name            Size     VMA      Type\n  0                 00000000 00000000 \n  1 .vector_table   000000c0 10000100 DATA\n  2 .boot_loader    00000100 10000000 DATA\n  3 .text           00000b10 100001c0 TEXT\n  4 .rodata         000001a4 10000cd0 DATA\n  5 .data           00000000 20000000 DATA\n  6 .gnu.sgstubs    00000000 10000e80 TEXT\n  7 .bss            00000000 20000000 BSS\n  8 .uninit         00000000 20000000 BSS\n  9 .debug_abbrev   00001bce 00000000 DEBUG\n 10 .debug_info     00025316 00000000 DEBUG\n 11 .debug_aranges  000014b8 00000000 DEBUG\n 12 .debug_str      0003c860 00000000 DEBUG\n 13 .debug_pubnames 000175c6 00000000 DEBUG\n 14 .debug_pubtypes 00000ee6 00000000 DEBUG\n 15 .comment        00000073 00000000 \n 16 .ARM.attributes 00000032 00000000 \n 17 .debug_frame    00004444 00000000 DEBUG\n 18 .debug_line     00023790 00000000 DEBUG\n 19 .debug_ranges   00016df8 00000000 DEBUG\n 20 .debug_loc      00000074 00000000 DEBUG\n 21 .symtab         00000970 00000000 \n 22 .shstrtab       00000103 00000000 \n 23 .strtab         00000fe4 00000000 \n"})}),"\n",(0,r.jsx)(n.h3,{id:"disassemble-a-specific-section",children:"Disassemble a specific section"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"rust-objdump --disassemble -j .section_name target/thumbv6m-none-eabi/debug/<executable_name>\n"})}),"\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"cargo objdumb"})," and ",(0,r.jsx)(n.code,{children:"rust-objdump"})," tools use llvm's ",(0,r.jsx)(n.code,{children:"objdump"})," tool.\nSome terminals do not parse parameters proxied to ",(0,r.jsx)(n.code,{children:"llvm-objdump"})," command.\nIf this happens please use ",(0,r.jsx)(n.code,{children:"llvm-objdump"})," script directly like so"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"llvm-objdump <path_to_binary> --section.headers\n"})})]}),"\n",(0,r.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Connect an LED1 to pin 0 and an LED2 to pin 1. Use ",(0,r.jsx)(n.a,{href:"https://www.kicad.org/",children:"KiCad"})," to draw the schematics."]}),"\n",(0,r.jsxs)(n.li,{children:["Write a program using ",(0,r.jsx)(n.code,{children:"embedded-hal"})," that blinks the LED2. Use ",(0,r.jsx)(n.code,{children:"rust-objdump"})," to display the sections."]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["Use the code from ",(0,r.jsx)(n.a,{href:"/docs/lab/02",children:"Lab 02"}),"."]})}),"\n",(0,r.jsx)(n.p,{children:"You should be able to see the:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"bootloader section"}),"\n",(0,r.jsx)(n.li,{children:"interrupt vector"}),"\n",(0,r.jsx)(n.li,{children:"the code part (.text segment)"}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsxs)(n.li,{children:["Register a hard fault handler that blinks LED2.","\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Generate a hard fault, you should see LED1 stop blinking (either on or off) and the LED2 blink"}),"\n",(0,r.jsx)(n.li,{children:"Move the blinking LED2 code to the panic handler and make sure it is called when a hard fault is generated."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Register an interrupt on the pin connected to button A. Toggle an LED each time the button is pressed."}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"embassy-rs"})," to obtain the same result."]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"Spawning a new task might be a good idea."})})]})}function h(e={}){const{wrapper:n}={...(0,s.M)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},7180:(e,n,t)=>{t.d(n,{c:()=>r});const r=t.p+"assets/images/IRQrp2040-ae016aa4bd46728ca373d2658729e24d.png"},1344:(e,n,t)=>{t.d(n,{c:()=>r});const r=t.p+"assets/images/M0regs-0eec2be5ea84b8c8430cdb991261f196.png"},1924:(e,n,t)=>{t.d(n,{c:()=>r});const r=t.p+"assets/images/VectorTable_ARM_CortexM0-e0ca77fcbfd7a757f3c2ef6d85206986.png"},6780:(e,n,t)=>{t.d(n,{c:()=>r});const r=t.p+"assets/images/embassy_irq-3d64afb551c444b331ae08517354d63b.png"},3668:(e,n,t)=>{t.d(n,{c:()=>r});const r=t.p+"assets/images/flash_address-f6b4184a1da876a7e83752b2ff6e1d68.svg"},8932:(e,n,t)=>{t.d(n,{c:()=>r});const r="data:image/png;base64,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"},2660:(e,n,t)=>{t.d(n,{c:()=>r});const r=t.p+"assets/images/rpsubsystem-8fa22f1ea9fa8ec9021a165ee2640150.png"},4748:(e,n,t)=>{t.d(n,{c:()=>r});const r=t.p+"assets/images/stack_frame-0dc91615c2f2f0409a3df507e0086f49.png"},2172:(e,n,t)=>{t.d(n,{I:()=>o,M:()=>a});var r=t(1504);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);